// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: menu.sql

package db

import (
	"context"
	"encoding/json"
	"time"
)

const createMenu = `-- name: CreateMenu :exec
INSERT INTO menus (
    id,
    offered_at,
    photo_url,
    elementary_school_calories,
    junior_high_school_calories
  )
VALUES (
    ?,
    ?,
    ?,
    ?,
    ?
  )
`

type CreateMenuParams struct {
	ID                       string    `json:"id"`
	OfferedAt                time.Time `json:"offered_at"`
	PhotoUrl                 string    `json:"photo_url"`
	ElementarySchoolCalories int32     `json:"elementary_school_calories"`
	JuniorHighSchoolCalories int32     `json:"junior_high_school_calories"`
}

func (q *Queries) CreateMenu(ctx context.Context, arg CreateMenuParams) error {
	_, err := q.db.ExecContext(ctx, createMenu,
		arg.ID,
		arg.OfferedAt,
		arg.PhotoUrl,
		arg.ElementarySchoolCalories,
		arg.JuniorHighSchoolCalories,
	)
	return err
}

const getMenu = `-- name: GetMenu :one
SELECT id, offered_at, photo_url, created_at, elementary_school_calories, junior_high_school_calories
FROM menus
WHERE id = ?
`

func (q *Queries) GetMenu(ctx context.Context, id string) (Menu, error) {
	row := q.db.QueryRowContext(ctx, getMenu, id)
	var i Menu
	err := row.Scan(
		&i.ID,
		&i.OfferedAt,
		&i.PhotoUrl,
		&i.CreatedAt,
		&i.ElementarySchoolCalories,
		&i.JuniorHighSchoolCalories,
	)
	return i, err
}

const getMenuByOfferedAt = `-- name: GetMenuByOfferedAt :one
SELECT id, offered_at, photo_url, created_at, elementary_school_calories, junior_high_school_calories
FROM menus
WHERE offered_at = ?
`

func (q *Queries) GetMenuByOfferedAt(ctx context.Context, offeredAt time.Time) (Menu, error) {
	row := q.db.QueryRowContext(ctx, getMenuByOfferedAt, offeredAt)
	var i Menu
	err := row.Scan(
		&i.ID,
		&i.OfferedAt,
		&i.PhotoUrl,
		&i.CreatedAt,
		&i.ElementarySchoolCalories,
		&i.JuniorHighSchoolCalories,
	)
	return i, err
}

const getMenuWithDishes = `-- name: GetMenuWithDishes :one
SELECT m.id, m.offered_at, m.photo_url, m.created_at, m.elementary_school_calories, m.junior_high_school_calories,
  JSON_ARRAYAGG(
    JSON_OBJECT(
      'id',
      d.id,
      'name',
      d.name,
      'menu_id',
      d.menu_id
    )
  ) AS dishes
FROM menus AS m
  LEFT JOIN dishes AS d ON m.id = d.menu_id
WHERE m.id = ?
GROUP BY m.id
`

type GetMenuWithDishesRow struct {
	ID                       string          `json:"id"`
	OfferedAt                time.Time       `json:"offered_at"`
	PhotoUrl                 string          `json:"photo_url"`
	CreatedAt                time.Time       `json:"created_at"`
	ElementarySchoolCalories int32           `json:"elementary_school_calories"`
	JuniorHighSchoolCalories int32           `json:"junior_high_school_calories"`
	Dishes                   json.RawMessage `json:"dishes"`
}

func (q *Queries) GetMenuWithDishes(ctx context.Context, id string) (GetMenuWithDishesRow, error) {
	row := q.db.QueryRowContext(ctx, getMenuWithDishes, id)
	var i GetMenuWithDishesRow
	err := row.Scan(
		&i.ID,
		&i.OfferedAt,
		&i.PhotoUrl,
		&i.CreatedAt,
		&i.ElementarySchoolCalories,
		&i.JuniorHighSchoolCalories,
		&i.Dishes,
	)
	return i, err
}

const getMenuWithDishesByOfferedAt = `-- name: GetMenuWithDishesByOfferedAt :one
SELECT m.id, m.offered_at, m.photo_url, m.created_at, m.elementary_school_calories, m.junior_high_school_calories,
  JSON_ARRAYAGG(
    JSON_OBJECT(
      'id',
      d.id,
      'name',
      d.name,
      'menu_id',
      d.menu_id
    )
  ) AS dishes
FROM menus AS m
  LEFT JOIN dishes AS d ON m.id = d.menu_id
WHERE m.offered_at = ?
GROUP BY m.id
`

type GetMenuWithDishesByOfferedAtRow struct {
	ID                       string          `json:"id"`
	OfferedAt                time.Time       `json:"offered_at"`
	PhotoUrl                 string          `json:"photo_url"`
	CreatedAt                time.Time       `json:"created_at"`
	ElementarySchoolCalories int32           `json:"elementary_school_calories"`
	JuniorHighSchoolCalories int32           `json:"junior_high_school_calories"`
	Dishes                   json.RawMessage `json:"dishes"`
}

func (q *Queries) GetMenuWithDishesByOfferedAt(ctx context.Context, offeredAt time.Time) (GetMenuWithDishesByOfferedAtRow, error) {
	row := q.db.QueryRowContext(ctx, getMenuWithDishesByOfferedAt, offeredAt)
	var i GetMenuWithDishesByOfferedAtRow
	err := row.Scan(
		&i.ID,
		&i.OfferedAt,
		&i.PhotoUrl,
		&i.CreatedAt,
		&i.ElementarySchoolCalories,
		&i.JuniorHighSchoolCalories,
		&i.Dishes,
	)
	return i, err
}

const listMenuWithDishes = `-- name: ListMenuWithDishes :many
SELECT m.id, m.offered_at, m.photo_url, m.created_at, m.elementary_school_calories, m.junior_high_school_calories,
  JSON_ARRAYAGG(
    JSON_OBJECT(
      'id',
      d.id,
      'name',
      d.name,
      'menu_id',
      d.menu_id
    )
  ) AS dishes
FROM menus AS m
  LEFT JOIN dishes AS d ON m.id = d.menu_id
GROUP BY m.id
ORDER BY offered_at
LIMIT ? OFFSET ?
`

type ListMenuWithDishesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListMenuWithDishesRow struct {
	ID                       string          `json:"id"`
	OfferedAt                time.Time       `json:"offered_at"`
	PhotoUrl                 string          `json:"photo_url"`
	CreatedAt                time.Time       `json:"created_at"`
	ElementarySchoolCalories int32           `json:"elementary_school_calories"`
	JuniorHighSchoolCalories int32           `json:"junior_high_school_calories"`
	Dishes                   json.RawMessage `json:"dishes"`
}

func (q *Queries) ListMenuWithDishes(ctx context.Context, arg ListMenuWithDishesParams) ([]ListMenuWithDishesRow, error) {
	rows, err := q.db.QueryContext(ctx, listMenuWithDishes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMenuWithDishesRow{}
	for rows.Next() {
		var i ListMenuWithDishesRow
		if err := rows.Scan(
			&i.ID,
			&i.OfferedAt,
			&i.PhotoUrl,
			&i.CreatedAt,
			&i.ElementarySchoolCalories,
			&i.JuniorHighSchoolCalories,
			&i.Dishes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMenuWithDishesByOfferedAt = `-- name: ListMenuWithDishesByOfferedAt :many
SELECT m.id, m.offered_at, m.photo_url, m.created_at, m.elementary_school_calories, m.junior_high_school_calories,
  JSON_ARRAYAGG(
    JSON_OBJECT(
      'id',
      d.id,
      'name',
      d.name,
      'menu_id',
      d.menu_id
    )
  ) AS dishes
FROM menus AS m
  LEFT JOIN dishes AS d ON m.id = d.menu_id
WHERE m.offered_at >= ?
  AND m.offered_at <= ?
GROUP BY m.id
ORDER BY offered_at
LIMIT ?
`

type ListMenuWithDishesByOfferedAtParams struct {
	StartOfferedAt time.Time `json:"start_offered_at"`
	EndOfferedAt   time.Time `json:"end_offered_at"`
	Limit          int32     `json:"limit"`
}

type ListMenuWithDishesByOfferedAtRow struct {
	ID                       string          `json:"id"`
	OfferedAt                time.Time       `json:"offered_at"`
	PhotoUrl                 string          `json:"photo_url"`
	CreatedAt                time.Time       `json:"created_at"`
	ElementarySchoolCalories int32           `json:"elementary_school_calories"`
	JuniorHighSchoolCalories int32           `json:"junior_high_school_calories"`
	Dishes                   json.RawMessage `json:"dishes"`
}

func (q *Queries) ListMenuWithDishesByOfferedAt(ctx context.Context, arg ListMenuWithDishesByOfferedAtParams) ([]ListMenuWithDishesByOfferedAtRow, error) {
	rows, err := q.db.QueryContext(ctx, listMenuWithDishesByOfferedAt, arg.StartOfferedAt, arg.EndOfferedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMenuWithDishesByOfferedAtRow{}
	for rows.Next() {
		var i ListMenuWithDishesByOfferedAtRow
		if err := rows.Scan(
			&i.ID,
			&i.OfferedAt,
			&i.PhotoUrl,
			&i.CreatedAt,
			&i.ElementarySchoolCalories,
			&i.JuniorHighSchoolCalories,
			&i.Dishes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMenus = `-- name: ListMenus :many
SELECT id, offered_at, photo_url, created_at, elementary_school_calories, junior_high_school_calories
FROM menus AS m
ORDER BY offered_at
LIMIT ? OFFSET ?
`

type ListMenusParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListMenus(ctx context.Context, arg ListMenusParams) ([]Menu, error) {
	rows, err := q.db.QueryContext(ctx, listMenus, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Menu{}
	for rows.Next() {
		var i Menu
		if err := rows.Scan(
			&i.ID,
			&i.OfferedAt,
			&i.PhotoUrl,
			&i.CreatedAt,
			&i.ElementarySchoolCalories,
			&i.JuniorHighSchoolCalories,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMenusByOfferedAt = `-- name: ListMenusByOfferedAt :many
SELECT id, offered_at, photo_url, created_at, elementary_school_calories, junior_high_school_calories
FROM menus
WHERE offered_at >= ?
  AND offered_at < ?
ORDER BY offered_at
LIMIT ?
`

type ListMenusByOfferedAtParams struct {
	StartOfferedAt time.Time `json:"start_offered_at"`
	EndOfferedAt   time.Time `json:"end_offered_at"`
	Limit          int32     `json:"limit"`
}

func (q *Queries) ListMenusByOfferedAt(ctx context.Context, arg ListMenusByOfferedAtParams) ([]Menu, error) {
	rows, err := q.db.QueryContext(ctx, listMenusByOfferedAt, arg.StartOfferedAt, arg.EndOfferedAt, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Menu{}
	for rows.Next() {
		var i Menu
		if err := rows.Scan(
			&i.ID,
			&i.OfferedAt,
			&i.PhotoUrl,
			&i.CreatedAt,
			&i.ElementarySchoolCalories,
			&i.JuniorHighSchoolCalories,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
